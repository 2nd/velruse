.. _overview:

========
Overview
========

Velruse aims to simplify authenticating a user. It provides
:term:`auth provider`'s that handle authenticating to a variety of
identity providers with multiple authentication schemes (LDAP, SAML,
etc.). Eventually, Velruse will include widgets similar to `RPXNow`_ that
allow one to customize a login/registration widget so that a website
user can select a preferred identity provider to use to sign-in. In the
mean-time, effort is focused on increasing the available
:term:`auth provider`s for the commonly used authentication schemes
and identity providers (Facebook, Google, OpenID, etc). Unlike other
authentication libraries for use with web applications,
a website using Velruse for authentication **does not have to be
written in any particular language**.


API
===

Velruse implements an API similar to `RPXNow`_ to standardize the way a
web application handles user authentication. The standard flow of using
Velruse looks like this:

.. image:: _static/overview.png
   :alt: Velruse Authentication flow
   :align: center

1. Website sends a POST to the :term:`auth provider`'s URL with an endpoint
   that the user should be redirected back to when authentication is complete
   and includes any additional parameters that the :term:`auth provider`
   requires.
2. When the :term:`auth provider` finishes the authentication, the user is
   redirected back to the endpoint specified with a POST, which includes the
   user's authentication data.


Using in a Pyramid App
======================

To use velruse as a Pyramid plugin, you simply have to include the following
lines in your configuration:

.. code-block:: python

    config.include('velruse.providers.google')
    config.add_google_login(realm='http://www.example.com/')

After velruse is included in your app, you can easily generate a login url
for any particular provider.  This is accomplished by calling the
:func:`velruse.api.login_url` like so:

.. code-block:: python

    login_url(request, 'google')

In this case, the login_url() function will generate a url that looks like this:
http://www.example.com/login/google. A user can then be directed to that url when they
need to authenticate through the Google provider.  This is commonly done in the form of
a link or a button on the login page of your app.  At this stage, if you were to visit
the aforementioned url, you would find that the third party provider would error out.
This makes sense, b/c we haven't given velruse the consumer key nor the consumer secret
for our application.  These two values can be obtained by creating an application on
each of the provider's websites, commonly found in the "developers" section.  Once you
have obtained a consumer key and secret from each of the providers you wish to support,
we need to tell velruse about them.  We can easily do this by adding them to our app's
.ini files.  You can using the following example as a guide:

.. code-block:: ini

    provider.facebook.consumer_key = 411326239420890
    provider.facebook.consumer_secret = 81ef2318a1999tttc6d9c43d4e93be0c
    provider.facebook.scope =

    provider.tw.impl = twitter
    provider.tw.consumer_key = ULZ6PkJbeqwgGxZaCIbdEBZekrbgXwgXajRl
    provider.tw.consumer_secret = eoCrewnpdWXjfim5ayGgEPeHzjcQzFsqAchOEa

So the user has clicked on your link to a specific provider's login
handler(generated by login_url()), signed in through the respective provider's
interface, and is now being redirected back to our app.  To properly handle this
redirect, we need to add a couple views.  The first view we need to add is called
when authentication succeeds, and could potentially look something like this:

.. code-block:: python

    @view_config(
        context='velruse.AuthenticationComplete',
        renderer='myapp:templates/result.mako',
    )
    def login_complete_view(request):
        context = request.context
        result = {
            'profile': context.profile,
            'credentials': context.credentials,
        }
        return {
            'result': json.dumps(result, indent=4),
        }

The important thing to note here, is that we need to register a view that has a value of
'velruse.AuthenticationComplete' assigned to the context predicate.  This results in
the 'login_complete_view' to be called when a third party redirects to your app and was
successful.  This view will most likely be used to store credentials, create accounts,
and redirect the user to the rest of your application. If you want to create a view that
is only called when a *specific* third party's authentication succeeds, you can change the
view configuration to specify a more specific context like so:

.. code-block:: python

    @view_config(
        context='velruse.FacebookAuthenticationComplete',
        renderer='myapp:templates/result.mako',
    )
    def login_complete_view(request):
        pass

The second view we need to add is called when authentication fails, and could potentially look
something like this:

.. code-block:: python

    @view_config(
        context='velruse.AuthenticationDenied',
        renderer='myapp:templates/result.mako',
    )
    def login_denied_view(request):
        return {
            'result': 'denied',
        }

We assign a value of 'velruse.AuthenticationDenied' to the context predicate of the view.  This
results in the 'login_denied_view' to be called when a third party redirects to your app and reports
a failed authentication.  This view will most likely be used to display an appropriate error message, and
redirect the user.  After velruse is include/configured in your pyramid application, login urls
are generated for each of the providers that you want to suport, and the previous two views are
defined, you can effectively use velruse to authenticate with third party oauth providers.

.. warning::

    In order to get working code examples, you will probably need to change the
    realm to something sensible. Maybe "localhost" would work for testing.


Using Separate App as a Service
===============================

In addition to using velruse as a Pyramid plugin, you also have the option to communicate with velruse over
HTTP.  Velruse can potentially run as a separate web application, which has an api that makes it easy to
authenticate with various providers, as well as obtain user credentials and profile information
after a user has already been authenticated.  This allows virtually anyone to use velruse, regardless of their
chosen language or framework.

.. _RPXNow: http://rpxnow.com/
