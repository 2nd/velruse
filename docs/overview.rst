.. _overview:

========
Overview
========

Velruse aims to simplify authenticating a user. It provides
:term:`auth provider`'s that handle authenticating to a variety of
identity providers with multiple authentication schemes (LDAP, SAML,
etc.). Eventually, Velruse will include widgets similar to `RPXNow`_ that
allow one to customize a login/registration widget so that a website
user can select a preferred identity provider to use to sign-in. In the
mean-time, effort is focused on increasing the available
:term:`auth provider`s for the commonly used authentication schemes
and identity providers (Facebook, Google, OpenID, etc). Unlike other
authentication libraries for use with web applications,
a website using Velruse for authentication **does not have to be
written in any particular language**.


API
===

Velruse implements an API similar to `RPXNow`_ to standardize the way a
web application handles user authentication. The standard flow of using
Velruse looks like this:

.. image:: _static/overview.png
   :alt: Velruse Authentication flow
   :align: center

1. Website sends a POST to the :term:`auth provider`'s URL with an endpoint
   that the user should be redirected back to when authentication is complete
   and includes any additional parameters that the :term:`auth provider`
   requires.
2. When the :term:`auth provider` finishes the authentication, the user is
   redirected back to the endpoint specified with a POST, which includes the
   user's authentication data.


Using in a Pyramid App
======================

To use velruse as a Pyramid plugin, you simply have to include the following
lines in your configuration:

.. code-block:: python

    config.include('velruse.providers.google')
    config.add_google_login(realm='http://www.example.com/')

After velruse is included in your app, you can easily generate a login url
for any particular provider.  This is accomplished by calling the
:func:`velruse.api.login_url` like so:

.. code-block:: python

    login_url(request, 'google')

In this case, the login_url() function will generate a url that looks like this:
http://www.example.com/login/google. A user can then be directed to that url
when they need to authenticate through the Google provider.  This is commonly
done in the form of a link or a button on the login page of your app.  At this
stage, if you were to visit the aforementioned url, you would find that the
third party provider would error out. This makes sense, b/c we haven't given
velruse the consumer key nor the consumer secret for our application.  These
two values can be obtained by creating an application on each of the provider's
websites, commonly found in the "developers" section.  Once you have obtained a
consumer key and secret from each of the providers you wish to support, we need
to tell velruse about them.  We can easily do this by adding them to our app's
.ini files.  You can use the following example as a guide:

.. code-block:: ini

    provider.facebook.consumer_key = 411326239420890
    provider.facebook.consumer_secret = 81ef2318a1999tttc6d9c43d4e93be0c
    provider.facebook.scope =

    provider.tw.impl = twitter
    provider.tw.consumer_key = ULZ6PkJbeqwgGxZaCIbdEBZekrbgXwgXajRl
    provider.tw.consumer_secret = eoCrewnpdWXjfim5ayGgEPeHzjcQzFsqAchOEa

So the user has clicked on your link to a specific provider's login
handler(generated by login_url()), signed in through the respective provider's
interface, and is now being redirected back to our app.  To properly handle this
redirect, we need to add a couple views.  The first view we need to add is
called when authentication succeeds, and could potentially look something like
this:

.. code-block:: python

    @view_config(
        context='velruse.AuthenticationComplete',
        renderer='myapp:templates/result.mako',
    )
    def login_complete_view(request):
        context = request.context
        result = {
            'profile': context.profile,
            'credentials': context.credentials,
        }
        return {
            'result': json.dumps(result, indent=4),
        }

The important thing to note here, is that we need to register a view that has
a value of 'velruse.AuthenticationComplete' assigned to the context predicate.
This results in the 'login_complete_view' to be called when a third party
redirects to your app and was successful.  This view will most likely be used to
store credentials, create accounts, and redirect the user to the rest of your
application. If you want to create a view that is only called when a *specific*
third party's authentication succeeds, you can change the view configuration to
specify a more specific context like so:

.. code-block:: python

    @view_config(
        context='velruse.FacebookAuthenticationComplete',
        renderer='myapp:templates/result.mako',
    )
    def login_complete_view(request):
        pass

The second view we need to add is called when authentication fails, and could
potentially look something like this:

.. code-block:: python

    @view_config(
        context='velruse.AuthenticationDenied',
        renderer='myapp:templates/result.mako',
    )
    def login_denied_view(request):
        return {
            'result': 'denied',
        }

We assign a value of 'velruse.AuthenticationDenied' to the context predicate of
the view.  This results in the 'login_denied_view' to be called when a third
party redirects to your app and reports a failed authentication.  This view will
most likely be used to display an appropriate error message, and redirect the
user.  After velruse is include/configured in your pyramid application, login
urls are generated for each of the providers that you want to support, and the
previous two views are defined, you can effectively use velruse to authenticate
with third party oauth providers.

.. warning::

    In order to get working code examples, you will probably need to change the
    realm to something sensible. Maybe "localhost" would work for testing.


Using Separate App as a Service
===============================

In addition to using velruse as a Pyramid plugin, you also have the option to
communicate with velruse over HTTP.  Velruse can potentially run as a separate
web application, which has an api that makes it easy to authenticate with
various providers, as well as obtain user credentials and profile information
after a user has already been authenticated.  This allows virtually anyone to
use velruse, regardless of their chosen language or framework.  The standalone
app is a standard Pyramid application, so if you are familiar with the
framework, you will feel right at home.  We are going to assume you have no
experience with Pyramid just to be safe though.  We do, however, assume you have
knowledge of WSGI.

The first thing we need to do is provide the velruse standalone app with some
information about our application's account details for each provider we are
supporting.  Namely the consumer key and consumer secret of our app. These two
values can be obtained by creating an application on
each of the provider's websites, commonly found in the "developers" section.
Once you have obtained a consumer key and secret from each of the providers you
wish to support, we need to tell velruse about them.  This can be done by
creating creating an .ini file that will be used to serve the standalone app.
It could look something like the following:

.. code-block:: ini

    [server:main]
    use = egg:Paste#http
    host = 0.0.0.0
    port = 80

    [app:velruse]
    use = egg:velruse

    setup = myapp.setup_velruse

    endpoint = http://example.com/logged_in

    store = redis
    store.host = localhost
    store.port = 6379
    store.db = 0
    store.key_prefix = velruse_ustore

    provider.facebook.consumer_key = KMfXjzsA2qVUcnnRn3vpnwWZ2pwPRFZdb
    provider.facebook.consumer_secret = ULZ6PkJbsqw2GxZWCIbOEBZdkrb9XwgXNjRy
    provider.facebook.scope = email

    provider.tw.impl = twitter
    provider.tw.consumer_key = ULZ6PkJbsqw2GxZWCIbOEBZdkrb9XwgXNjRy
    provider.tw.consumer_secret = eoCrFwnpBWXjbim5dyG6EP7HzjhQzFsMAcQOEK

Ok so that's a lot of stuff.  Let's go through each section.  The values in the
'[server:main]' section are saying that we want to serve our app via the Paste
web server, to bind to any ip address, and to run on port 80.  Next, we have a
number of configuration options for our web app.  The important ones are as
follows:

setup
    A module that includes a standard Pyramid includeme() function, which
    modifies the standalone app's configuration.
endpoint
    The url that velruse will redirect to after it finishes authenticating with
    a provider.
store
    The type of cache that you would like velruse to use.
store.host
    The IP that you would like the cache to bind to.
store.port
    The port that you would like the cache to us.
store.db

store.key_prefix
    The prefix to prepend to every key that is created in the cache.

Finally, we define all of the provider-specific consumer keys and secrets that
we talked about earlier.  Reference the providers page for the various settings
that are possible for each provider.

Once we are done configuring the velruse standalone app, we can serve it by
simply typing:

.. code-block:: bash

    pserve example.ini

This will start serving velruse at the specified IP and port in your .ini file.
We can then communicate with the standalone app, by sending HTTP requests to
that IP/port.  The velruse api is quite simple, and it only consists of the
following two routes:

/login/{provider}
    Authenticates with a provider, and redirects back to the url specified by
    the endpoint setting.
/auth_info?format=json&token={token}
    Obtains the profile and credential information for a user with the specified
    token.

If you were to visit '/login/facebook', you would be prompted to authenticate
with Facebook.  After completing the oauth process, velruse would then redirect
to your endpoint using a POST request, with the token assigned to a user stored
in the form data.  This token is what you use on subsequent requests to obtain
authentication details about a user.  So if a user logs into your application,
and velruse assigns a token of the value 'token' to that user, then we can
access everything velruse knows about that user by visiting
'/auth_info?format=json&token=token'.

.. _RPXNow: http://rpxnow.com/
